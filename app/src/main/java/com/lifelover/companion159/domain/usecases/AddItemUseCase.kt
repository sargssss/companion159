package com.lifelover.companion159.domain.usecases

import android.util.Log
import com.lifelover.companion159.data.repository.InventoryRepository
import com.lifelover.companion159.domain.models.AppError
import com.lifelover.companion159.domain.models.DisplayCategory
import com.lifelover.companion159.domain.models.InventoryItem
import com.lifelover.companion159.domain.models.toStorageCategory
import com.lifelover.companion159.domain.validation.InputValidator
import javax.inject.Inject

/**
 * Use case for adding new inventory item
 *
 * Business rules:
 * - Name cannot be empty and must be 1-100 characters
 * - Quantities must be non-negative (0-999999)
 * - Display category determines storage category
 * - Item automatically queued for sync after creation
 *
 * Responsibilities:
 * - Validate all input fields
 * - Map display category to storage category
 * - Create domain model
 * - Delegate to repository for persistence
 *
 * @param repository Inventory repository for data persistence
 */
class AddItemUseCase @Inject constructor(
    private val repository: InventoryRepository
) {
    companion object {
        private const val TAG = "AddItemUseCase"
    }

    /**
     * Add new item with validation
     *
     * Flow:
     * 1. Validate input (name, quantities)
     * 2. Map display category → storage category
     * 3. Create InventoryItem domain model
     * 4. Save to repository (triggers sync queue)
     *
     * @param name Item name (will be trimmed)
     * @param availableQuantity Available quantity (>= 0)
     * @param neededQuantity Needed quantity (>= 0)
     * @param displayCategory Display category (Availability/Ammunition/Needs)
     * @return Result.success(Unit) on success, Result.failure(AppError) on validation/persistence error
     *
     * @throws IllegalStateException if user not authenticated or position not set (from repository)
     * @throws SecurityException if trying to modify other crew's data (from repository)
     */
    suspend operator fun invoke(
        name: String,
        availableQuantity: Int,
        neededQuantity: Int,
        displayCategory: DisplayCategory
    ): Result<Unit> {
        return try {
            Log.d(TAG, "=== ADD ITEM USE CASE ===")
            Log.d(TAG, "Input: name='$name', available=$availableQuantity, needed=$neededQuantity, category=${displayCategory.name}")

            // Step 1: Validate input
            val validationResult = InputValidator.validateNewItem(
                name = name,
                availableQuantity = availableQuantity,
                neededQuantity = neededQuantity
            )

            validationResult.fold(
                onSuccess = { validated ->
                    Log.d(TAG, "✅ Validation passed")
                    Log.d(TAG, "Validated: name='${validated.name}', available=${validated.availableQuantity}, needed=${validated.neededQuantity}")

                    // Step 2: Map display category to storage category
                    val storageCategory = displayCategory.toStorageCategory()
                    Log.d(TAG, "Mapped: ${displayCategory.name} → ${storageCategory.name}")

                    // Step 3: Create domain model
                    val item = InventoryItem(
                        id = 0, // Auto-generated by Room
                        itemName = validated.name,
                        availableQuantity = validated.availableQuantity,
                        neededQuantity = validated.neededQuantity,
                        category = storageCategory,
                        crewName = "" // Will be set by repository based on current position
                    )

                    // Step 4: Save to repository
                    Log.d(TAG, "Saving to repository...")
                    repository.addItem(item)

                    Log.d(TAG, "✅ Item added successfully")
                    Log.d(TAG, "=========================")
                    Result.success(Unit)
                },
                onFailure = { error ->
                    Log.w(TAG, "⚠️ Validation failed: ${error.message}")
                    Log.d(TAG, "=========================")
                    Result.failure(error)
                }
            )

        } catch (e: Exception) {
            Log.e(TAG, "❌ Failed to add item", e)
            Log.d(TAG, "=========================")
            Result.failure(
                if (e is AppError) e
                else AppError.Unknown("Failed to add item: ${e.message}", e)
            )
        }
    }
}